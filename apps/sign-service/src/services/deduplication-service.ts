import { createHash } from 'crypto';
import { logger } from '../utils/logger';

/**
 * Deduplication Index Entry
 */
export interface DeduplicationEntry {
  imageHash: string;
  proofId: string;
  proofUri: string;
  timestamp: number;
  accessCount: number;
  lastAccessed: number;
}

/**
 * Deduplication Statistics
 */
export interface DeduplicationStats {
  totalProofs: number;
  uniqueImages: number;
  duplicates: number;
  deduplicationRate: number;
  spaceSaved: number;
  lastUpdated: Date;
}

/**
 * Deduplication Service
 * 
 * Ensures same image always gets same proof
 * Prevents duplicate storage of identical images
 */
export class DeduplicationService {
  private index: Map<string, DeduplicationEntry>;
  private stats: {
    lookups: number;
    hits: number;
    misses: number;
    duplicatesPrevented: number;
  };

  constructor() {
    this.index = new Map();
    this.stats = {
      lookups: 0,
      hits: 0,
      misses: 0,
      duplicatesPrevented: 0
    };

    logger.info('Deduplication Service initialized');
  }

  /**
   * Get or create proof ID for image hash
   */
  async getOrCreateProofId(imageHash: string): Promise<{ proofId: string; isNew: boolean }> {
    this.stats.lookups++;

    // Normalize hash
    const normalizedHash = this.normalizeHash(imageHash);

    // Check if we've seen this image before
    const existing = this.index.get(normalizedHash);
    
    if (existing) {
      // Update access statistics
      existing.accessCount++;
      existing.lastAccessed = Date.now();
      this.stats.hits++;
      this.stats.duplicatesPrevented++;

      logger.debug('Deduplication hit', {
        imageHash: normalizedHash,
        proofId: existing.proofId,
        accessCount: existing.accessCount
      });

      return {
        proofId: existing.proofId,
        isNew: false
      };
    }

    // New image - will be indexed when proof is stored
    this.stats.misses++;
    
    return {
      proofId: '', // Will be generated by caller
      isNew: true
    };
  }

  /**
   * Register a new proof in the deduplication index
   */
  async registerProof(imageHash: string, proofId: string, proofUri: string): Promise<void> {
    const normalizedHash = this.normalizeHash(imageHash);

    // Check if already registered
    if (this.index.has(normalizedHash)) {
      logger.warn('Attempted to register duplicate proof', {
        imageHash: normalizedHash,
        existingProofId: this.index.get(normalizedHash)?.proofId,
        newProofId: proofId
      });
      return;
    }

    // Register new proof
    this.index.set(normalizedHash, {
      imageHash: normalizedHash,
      proofId,
      proofUri,
      timestamp: Date.now(),
      accessCount: 1,
      lastAccessed: Date.now()
    });

    logger.debug('Proof registered in deduplication index', {
      imageHash: normalizedHash,
      proofId,
      indexSize: this.index.size
    });
  }

  /**
   * Get proof ID for image hash (if exists)
   */
  async getProofId(imageHash: string): Promise<string | null> {
    const normalizedHash = this.normalizeHash(imageHash);
    const entry = this.index.get(normalizedHash);
    
    if (entry) {
      entry.accessCount++;
      entry.lastAccessed = Date.now();
      return entry.proofId;
    }
    
    return null;
  }

  /**
   * Get proof URI for image hash (if exists)
   */
  async getProofUri(imageHash: string): Promise<string | null> {
    const normalizedHash = this.normalizeHash(imageHash);
    const entry = this.index.get(normalizedHash);
    return entry ? entry.proofUri : null;
  }

  /**
   * Check if image hash exists
   */
  async exists(imageHash: string): Promise<boolean> {
    const normalizedHash = this.normalizeHash(imageHash);
    return this.index.has(normalizedHash);
  }

  /**
   * Remove proof from index
   */
  async removeProof(imageHash: string): Promise<boolean> {
    const normalizedHash = this.normalizeHash(imageHash);
    const deleted = this.index.delete(normalizedHash);
    
    if (deleted) {
      logger.debug('Proof removed from deduplication index', {
        imageHash: normalizedHash
      });
    }
    
    return deleted;
  }

  /**
   * Get deduplication statistics
   */
  getStats(): DeduplicationStats {
    const hitRate = this.stats.lookups > 0 
      ? this.stats.hits / this.stats.lookups 
      : 0;

    return {
      totalProofs: this.index.size,
      uniqueImages: this.index.size,
      duplicates: this.stats.duplicatesPrevented,
      deduplicationRate: hitRate,
      spaceSaved: this.stats.duplicatesPrevented * 1024 * 1024, // Estimate 1MB per proof
      lastUpdated: new Date()
    };
  }

  /**
   * Get most accessed proofs
   */
  getMostAccessed(limit: number = 10): DeduplicationEntry[] {
    return Array.from(this.index.values())
      .sort((a, b) => b.accessCount - a.accessCount)
      .slice(0, limit);
  }

  /**
   * Get recently accessed proofs
   */
  getRecentlyAccessed(limit: number = 10): DeduplicationEntry[] {
    return Array.from(this.index.values())
      .sort((a, b) => b.lastAccessed - a.lastAccessed)
      .slice(0, limit);
  }

  /**
   * Clear old entries (cleanup)
   */
  async cleanup(maxAge: number = 30 * 24 * 60 * 60 * 1000): Promise<number> {
    const now = Date.now();
    let removed = 0;

    for (const [hash, entry] of this.index.entries()) {
      if (now - entry.lastAccessed > maxAge) {
        this.index.delete(hash);
        removed++;
      }
    }

    if (removed > 0) {
      logger.info('Deduplication index cleanup', {
        removed,
        remaining: this.index.size
      });
    }

    return removed;
  }

  /**
   * Export index for persistence
   */
  exportIndex(): string {
    const data = Array.from(this.index.entries());
    return JSON.stringify(data);
  }

  /**
   * Import index from persistence
   */
  importIndex(data: string): void {
    try {
      const entries = JSON.parse(data) as Array<[string, DeduplicationEntry]>;
      this.index = new Map(entries);
      
      logger.info('Deduplication index imported', {
        entries: this.index.size
      });
    } catch (error) {
      logger.error('Failed to import deduplication index', { error });
    }
  }

  /**
   * Clear entire index
   */
  clear(): void {
    this.index.clear();
    this.stats = {
      lookups: 0,
      hits: 0,
      misses: 0,
      duplicatesPrevented: 0
    };
    logger.info('Deduplication index cleared');
  }

  /**
   * Normalize hash to consistent format
   */
  private normalizeHash(hash: string): string {
    // Ensure consistent lowercase hex format
    return hash.toLowerCase().trim();
  }

  /**
   * Generate content hash from buffer (for verification)
   */
  static generateHash(buffer: Buffer): string {
    return createHash('sha256').update(buffer).digest('hex');
  }
}
