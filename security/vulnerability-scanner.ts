/**
 * AUTOMATED VULNERABILITY SCANNER
 * 
 * Continuous vulnerability scanning and security monitoring system
 * for real-time threat detection and automated security validation.
 * 
 * COMPLIANCE: CVE, CWE, CVSS, NVD
 */

import { createHash } from 'crypto';
import { execSync } from 'child_process';
import { readFileSync, writeFileSync } from 'fs';
import { join } from 'path';

export interface Vulnerability {
  id: string;
  type: 'CVE' | 'CWE' | 'CUSTOM';
  severity: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW';
  title: string;
  description: string;
  component: string;
  version: string;
  fixedIn?: string;
  cvssScore?: number;
  references: string[];
  discovered: string;
  status: 'OPEN' | 'FIXED' | 'WONT_FIX' | 'FALSE_POSITIVE';
}

export interface ScanResult {
  scanId: string;
  timestamp: string;
  scanner: string;
  target: string;
  vulnerabilities: Vulnerability[];
  summary: {
    total: number;
    critical: number;
    high: number;
    medium: number;
    low: number;
  };
  riskScore: number;
  recommendations: string[];
}

export interface SecurityMetrics {
  scanCount: number;
  vulnerabilitiesFound: number;
  vulnerabilitiesFixed: number;
  meanTimeToFix: number;
  riskTrend: 'IMPROVING' | 'STABLE' | 'DEGRADING';
  lastScan: string;
}

class AutomatedVulnerabilityScanner {
  private scanHistory: ScanResult[] = [];
  private metrics: SecurityMetrics = {
    scanCount: 0,
    vulnerabilitiesFound: 0,
    vulnerabilitiesFixed: 0,
    meanTimeToFix: 0,
    riskTrend: 'STABLE',
    lastScan: ''
  };

  /**
   * CRITICAL: Execute comprehensive vulnerability scan
   */
  async executeComprehensiveScan(targetPath: string): Promise<ScanResult> {
    const scanId = this.generateScanId();
    const timestamp = new Date().toISOString();
    
    console.log(`üîç Starting comprehensive vulnerability scan: ${scanId}`);
    
    const vulnerabilities: Vulnerability[] = [];
    
    // 1. Dependency vulnerability scanning
    const depVulns = await this.scanDependencies(targetPath);
    vulnerabilities.push(...depVulns);
    
    // 2. Code vulnerability scanning
    const codeVulns = await this.scanCodebase(targetPath);
    vulnerabilities.push(...codeVulns);
    
    // 3. Container vulnerability scanning
    const containerVulns = await this.scanContainers(targetPath);
    vulnerabilities.push(...containerVulns);
    
    // 4. Infrastructure vulnerability scanning
    const infraVulns = await this.scanInfrastructure(targetPath);
    vulnerabilities.push(...infraVulns);
    
    // 5. Configuration vulnerability scanning
    const configVulns = await this.scanConfiguration(targetPath);
    vulnerabilities.push(...configVulns);

    const result: ScanResult = {
      scanId,
      timestamp,
      scanner: 'AutomatedVulnerabilityScanner v1.0.0',
      target: targetPath,
      vulnerabilities,
      summary: this.calculateSummary(vulnerabilities),
      riskScore: this.calculateRiskScore(vulnerabilities),
      recommendations: this.generateRecommendations(vulnerabilities)
    };

    // Update metrics
    this.updateMetrics(result);
    this.scanHistory.push(result);

    // Save scan results
    this.saveScanResult(result);

    return result;
  }

  /**
   * Scan for dependency vulnerabilities
   */
  private async scanDependencies(targetPath: string): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];
    
    try {
      // Run pnpm audit
      const auditResult = execSync('pnpm audit --json', { 
        encoding: 'utf8',
        cwd: targetPath 
      });
      
      const audit = JSON.parse(auditResult);
      
      for (const [packageName, vulnData] of Object.entries(audit.vulnerabilities || {})) {
        const vuln = vulnData as any;
        
        vulnerabilities.push({
          id: vuln.cwe || `DEP-${packageName}`,
          type: 'CVE',
          severity: this.mapSeverity(vuln.severity),
          title: `Dependency vulnerability in ${packageName}`,
          description: vuln.title || `Vulnerability in ${packageName}`,
          component: packageName,
          version: vuln.version || 'unknown',
          fixedIn: vuln.fixAvailable?.version,
          cvssScore: vuln.cvssScore,
          references: vuln.url ? [vuln.url] : [],
          discovered: new Date().toISOString(),
          status: 'OPEN'
        });
      }
    } catch (error) {
      console.warn(`Dependency scan failed: ${error.message}`);
    }

    return vulnerabilities;
  }

  /**
   * Scan codebase for security vulnerabilities
   */
  private async scanCodebase(targetPath: string): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];
    
    // Static analysis patterns
    const securityPatterns = [
      {
        pattern: /eval\s*\(/gi,
        type: 'Code Injection',
        severity: 'CRITICAL' as const,
        cwe: 'CWE-94'
      },
      {
        pattern: /exec\s*\(/gi,
        type: 'Command Injection',
        severity: 'CRITICAL' as const,
        cwe: 'CWE-78'
      },
      {
        pattern: /innerHTML\s*=/gi,
        type: 'XSS',
        severity: 'HIGH' as const,
        cwe: 'CWE-79'
      },
      {
        pattern: /document\.write/gi,
        type: 'XSS',
        severity: 'HIGH' as const,
        cwe: 'CWE-79'
      },
      {
        pattern: /process\.env\./gi,
        type: 'Information Disclosure',
        severity: 'MEDIUM' as const,
        cwe: 'CWE-200'
      },
      {
        pattern: /console\.log/gi,
        type: 'Information Disclosure',
        severity: 'LOW' as const,
        cwe: 'CWE-200'
      }
    ];

    // Scan TypeScript/JavaScript files
    const files = this.getSourceFiles(targetPath);
    
    for (const file of files) {
      try {
        const content = readFileSync(file, 'utf8');
        
        for (const pattern of securityPatterns) {
          const matches = content.match(pattern.pattern);
          if (matches) {
            vulnerabilities.push({
              id: pattern.cwe,
              type: 'CWE',
              severity: pattern.severity,
              title: `${pattern.type} in ${file}`,
              description: `Potential ${pattern.type.toLowerCase()} vulnerability detected`,
              component: file,
              version: 'current',
              cvssScore: this.getCVSSScore(pattern.severity),
              references: [`https://cwe.mitre.org/data/definitions/${pattern.cwe.split('-')[1]}.html`],
              discovered: new Date().toISOString(),
              status: 'OPEN'
            });
          }
        }
      } catch (error) {
        console.warn(`Failed to scan ${file}: ${error.message}`);
      }
    }

    return vulnerabilities;
  }

  /**
   * Scan containers for vulnerabilities
   */
  private async scanContainers(targetPath: string): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];
    
    try {
      // Check Dockerfile for security issues
      const dockerfilePath = join(targetPath, 'Dockerfile');
      const dockerfileContent = readFileSync(dockerfilePath, 'utf8');
      
      // Check for security issues in Dockerfile
      const dockerSecurityChecks = [
        {
          pattern: /FROM.*:latest/gi,
          type: 'Latest Tag Usage',
          severity: 'MEDIUM' as const,
          description: 'Using latest tag can lead to unpredictable builds'
        },
        {
          pattern: /USER root/gi,
          type: 'Root User',
          severity: 'HIGH' as const,
          description: 'Running as root user is dangerous'
        },
        {
          pattern: /--privileged/gi,
          type: 'Privileged Mode',
          severity: 'CRITICAL' as const,
          description: 'Privileged mode gives extensive capabilities'
        },
        {
          pattern: /ADD\s+\.\./gi,
          type: 'Path Traversal',
          severity: 'HIGH' as const,
          description: 'ADD with ../ can lead to path traversal'
        }
      ];

      for (const check of dockerSecurityChecks) {
        if (check.pattern.test(dockerfileContent)) {
          vulnerabilities.push({
            id: 'DOCKER-' + check.type.replace(/\s+/g, '_'),
            type: 'CUSTOM',
            severity: check.severity,
            title: check.type,
            description: check.description,
            component: 'Dockerfile',
            version: 'current',
            cvssScore: this.getCVSSScore(check.severity),
            references: [],
            discovered: new Date().toISOString(),
            status: 'OPEN'
          });
        }
      }
    } catch (error) {
      console.warn(`Container scan failed: ${error.message}`);
    }

    return vulnerabilities;
  }

  /**
   * Scan infrastructure for vulnerabilities
   */
  private async scanInfrastructure(targetPath: string): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];
    
    try {
      // Check docker-compose.yml for security issues
      const composePath = join(targetPath, 'docker-compose.yml');
      const composeContent = readFileSync(composePath, 'utf8');
      
      // Check for security issues in docker-compose
      const composeSecurityChecks = [
        {
          pattern: /volumes:\s*-\s*\.\//gi,
          type: 'Host Filesystem Access',
          severity: 'CRITICAL' as const,
          description: 'Direct host filesystem access can lead to container escape'
        },
        {
          pattern: /privileged:\s*true/gi,
          type: 'Privileged Containers',
          severity: 'CRITICAL' as const,
          description: 'Privileged containers have extensive host access'
        },
        {
          pattern: /cap_add:\s*\[\]/gi,
          type: 'Missing Capability Restrictions',
          severity: 'HIGH' as const,
          description: 'Containers should drop all capabilities and add only what\'s needed'
        }
      ];

      for (const check of composeSecurityChecks) {
        if (check.pattern.test(composeContent)) {
          vulnerabilities.push({
            id: 'COMPOSE-' + check.type.replace(/\s+/g, '_'),
            type: 'CUSTOM',
            severity: check.severity,
            title: check.type,
            description: check.description,
            component: 'docker-compose.yml',
            version: 'current',
            cvssScore: this.getCVSSScore(check.severity),
            references: [],
            discovered: new Date().toISOString(),
            status: 'OPEN'
          });
        }
      }
    } catch (error) {
      console.warn(`Infrastructure scan failed: ${error.message}`);
    }

    return vulnerabilities;
  }

  /**
   * Scan configuration for vulnerabilities
   */
  private async scanConfiguration(targetPath: string): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];
    
    try {
      // Check package.json for security issues
      const packagePath = join(targetPath, 'package.json');
      const packageContent = JSON.parse(readFileSync(packagePath, 'utf8'));
      
      // Check for missing security scripts
      const securityScripts = ['security:audit', 'security:check', 'security:fix'];
      const existingScripts = Object.keys(packageContent.scripts || {});
      
      for (const script of securityScripts) {
        if (!existingScripts.includes(script)) {
          vulnerabilities.push({
            id: 'CONFIG-' + script.replace(':', '_'),
            type: 'CUSTOM',
            severity: 'MEDIUM',
            title: `Missing Security Script: ${script}`,
            description: `Security script ${script} is not defined in package.json`,
            component: 'package.json',
            version: 'current',
            cvssScore: 3.0,
            references: [],
            discovered: new Date().toISOString(),
            status: 'OPEN'
          });
        }
      }
    } catch (error) {
      console.warn(`Configuration scan failed: ${error.message}`);
    }

    return vulnerabilities;
  }

  /**
   * Get source files for scanning
   */
  private getSourceFiles(targetPath: string): string[] {
    // This would normally use a proper file system walk
    // For now, return common file patterns
    return [
      join(targetPath, 'apps/verify-api/src/verification.ts'),
      join(targetPath, 'apps/verify-api/src/crypto.ts'),
      join(targetPath, 'packages/c2-badge/src/c2-badge.ts'),
      join(targetPath, 'apps/manifest-store-worker/src/index.ts')
    ];
  }

  /**
   * Map severity from pnpm audit to our format
   */
  private mapSeverity(severity: string): 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW' {
    switch (severity?.toLowerCase()) {
      case 'critical':
        return 'CRITICAL';
      case 'high':
        return 'HIGH';
      case 'moderate':
        return 'MEDIUM';
      case 'low':
        return 'LOW';
      default:
        return 'MEDIUM';
    }
  }

  /**
   * Get CVSS score for severity
   */
  private getCVSSScore(severity: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW'): number {
    switch (severity) {
      case 'CRITICAL':
        return 9.0;
      case 'HIGH':
        return 7.0;
      case 'MEDIUM':
        return 5.0;
      case 'LOW':
        return 3.0;
      default:
        return 5.0;
    }
  }

  /**
   * Calculate vulnerability summary
   */
  private calculateSummary(vulnerabilities: Vulnerability[]) {
    return {
      total: vulnerabilities.length,
      critical: vulnerabilities.filter(v => v.severity === 'CRITICAL').length,
      high: vulnerabilities.filter(v => v.severity === 'HIGH').length,
      medium: vulnerabilities.filter(v => v.severity === 'MEDIUM').length,
      low: vulnerabilities.filter(v => v.severity === 'LOW').length
    };
  }

  /**
   * Calculate risk score
   */
  private calculateRiskScore(vulnerabilities: Vulnerability[]): number {
    let score = 0;
    
    for (const vuln of vulnerabilities) {
      switch (vuln.severity) {
        case 'CRITICAL':
          score += 10;
          break;
        case 'HIGH':
          score += 5;
          break;
        case 'MEDIUM':
          score += 2;
          break;
        case 'LOW':
          score += 1;
          break;
      }
    }
    
    return Math.min(score, 100);
  }

  /**
   * Generate recommendations
   */
  private generateRecommendations(vulnerabilities: Vulnerability[]): string[] {
    const recommendations: string[] = [];
    
    if (vulnerabilities.some(v => v.severity === 'CRITICAL')) {
      recommendations.push('IMMEDIATE ACTION REQUIRED: Fix all critical vulnerabilities');
    }
    
    if (vulnerabilities.some(v => v.type === 'CVE')) {
      recommendations.push('Update dependencies to fix CVE vulnerabilities');
    }
    
    if (vulnerabilities.some(v => v.component.includes('Dockerfile'))) {
      recommendations.push('Review and harden Docker configuration');
    }
    
    if (vulnerabilities.some(v => v.component.includes('docker-compose'))) {
      recommendations.push('Review and harden container orchestration');
    }
    
    recommendations.push('Implement regular vulnerability scanning in CI/CD pipeline');
    recommendations.push('Set up automated security patching');
    recommendations.push('Monitor security advisories for all dependencies');
    
    return recommendations;
  }

  /**
   * Update security metrics
   */
  private updateMetrics(result: ScanResult): void {
    this.metrics.scanCount++;
    this.metrics.vulnerabilitiesFound += result.summary.total;
    this.metrics.lastScan = result.timestamp;
    
    // Calculate risk trend (simplified)
    if (this.scanHistory.length > 0) {
      const lastResult = this.scanHistory[this.scanHistory.length - 1];
      if (result.riskScore < lastResult.riskScore) {
        this.metrics.riskTrend = 'IMPROVING';
      } else if (result.riskScore > lastResult.riskScore) {
        this.metrics.riskTrend = 'DEGRADING';
      } else {
        this.metrics.riskTrend = 'STABLE';
      }
    }
  }

  /**
   * Save scan result
   */
  private saveScanResult(result: ScanResult): void {
    try {
      const scanPath = join(process.cwd(), '.artifacts', 'security-scans');
      const filename = `scan-${result.scanId}.json`;
      writeFileSync(join(scanPath, filename), JSON.stringify(result, null, 2));
    } catch (error) {
      console.warn(`Failed to save scan result: ${error.message}`);
    }
  }

  /**
   * Generate scan ID
   */
  private generateScanId(): string {
    return `scan-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * Get security metrics
   */
  getMetrics(): SecurityMetrics {
    return { ...this.metrics };
  }

  /**
   * Get scan history
   */
  getScanHistory(): ScanResult[] {
    return [...this.scanHistory];
  }
}

export { AutomatedVulnerabilityScanner };
